# ğŸ“˜ SageMath Tutorial

This guide covers variable assignment, exact arithmetic, and common algebraic manipulationsâ€”all in a concise, copyâ€‘friendly format.

(Disclaimer: There is no good sage cell highlighting. although it is python on all of them, they are actually sage cell. )

---

## 1â€‚âœï¸ Assignment & Exact Arithmetic

| Task | Example | Notes |
|------|---------|-------|
| **Assign a value** | `a = 5` | Use `=` for assignment |
| **Compare values** | `a == 5` â†’ `True` | Use `==`, `!=`, `<`, `<=`, `>`, `>=` |
| **Last result** | `_` | Underscore holds the last output |
| **Exact fractions** | `1/3` â†’ `1/3` | Sage returns exact rationals, not floats |
| **Floating point** | `1/3.0` â†’ `0.333333333333333` | Add a decimal point (or use `float()`) |
| **Integer powers** | `2^10` â†’ `1024` | `^` or `**` both work |
| **Use Ï€,â€¯e,â€¯i** | `pi.n(50)`, `e^pi`, `I^2` | Builtâ€‘in constants |

### Quick tips

- Use `show(expr)` for nicely formatted math.
- Call `.n(k)` or `n(expr,â€¯k)` for a numeric approximation with *k* digits.
- Use `type(expr)` to inspect the Sage/Python type.

---

## 2â€‚â• Basic Arithmetic Operators

| Operator | Meaning | Example |
|----------|---------|---------|
| `+` | Addition | `2 + 3` â†’ `5` |
| `-` | Subtraction | `7 - 4` â†’ `3` |
| `*` | Multiplication | `6 * 8` â†’ `48` |
| `/` | Division (rational) | `7/2` â†’ `7/2` |
| `//` | Floor division | `7//2` â†’ `3` |
| `^`Â /Â `**` | Exponentiation | `3^4` â†’ `81` |
| `%` | Modulus | `17 % 5` â†’ `2` |

---

## 3â€‚ğŸ§® Symbolic Algebra

### 3.1â€‚Declare Symbols

- **`=` (assignment)** â€”Â bind a value or expression to a variable (e.g. `a = 5`).  
  Use only for assignment; equality tests use `==`.

- **`var('x y')`** â€”Â tell Sage that `x` and `y` are *symbolic* variables, so they behave algebraically (`x, y = var('x y')`).  
  Without this, a letter is treated as an ordinary Python name.

- **`function('f')`** â€”Â create a *symbolic function*Â `f`; calling it with an argument returns `f(t)` (e.g. `f = function('f')(t)`).  
  Useful for differentialâ€‘equation problems where you need an unknown function of `t`.

- **`show(expr)`** â€”Â display any expression in nicely formatted, typeset math (especially handy in Jupyter notebooks).  
  It does not alter the objectâ€”only the way itâ€™s rendered.

Together, these commands let you set up algebraic variables and functions quickly, assign values, and display results cleanly.


<details>
<summary><strong>ğŸ’» code </strong></summary>

```python
# Declare symbolic variables: time (t), initial velocity (v0), gravity (g)
t, v0, g = var('t v0 g')

# Height of a projectile:  h(t) = v0Â·t âˆ’ Â½Â·gÂ·tÂ²
h = v0*t - (g/2)*t^2
show(h)                 # â‡’  -1/2Â·gÂ·t^2 + v0Â·t

# Plug in v0 = 20â€¯m/s and g = 9.8â€¯m/sÂ²
h_sub = h.subs({v0: 20, g: 9.8})
h_sub                    # â‡’  -4.90000000000000*t^2 + 20*t

```
</details>

### 3.2  Manipulate Expressions

| Task                 | Command        | Example                           |
| -------------------- | -------------- | --------------------------------- |
| **Expand**           | `expand()`     | `(x + 1)^3 .expand()`             |
| **Factor**           | `factor()`     | `x^3 - 1 .factor()`               |
| **Simplify**         | `simplify()`   | `sin(x)^2 + cos(x)^2 .simplify()` |
| **Substitute**       | `subs()`       | `(x^2 + 1).subs(x=2)`        |
| **Evaluate numeric** | `subs`,Â `.n()` | `(sin(x)/x).subs(x=0.1).n()`      |

### 3.3â€‚Solving Equationsâ€¯â€”â€¯Exact vsâ€¯Numerical


<details>
<summary><strong>ğŸ’» code (click to see more) </strong></summary>

```python
# Declare symbolic variables
x, y = var('x y')

# â”€â”€ 1 Â· Exact (symbolic) solves â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
quad_roots   = solve(x^2 + 3*x + 2 == 0, x)          # quadratic equation
quad_roots                                        # â‡’ [x == -2, x == -1]

lin_system    = solve([x + y == 6, x - y == 4], x, y)  # linear system
lin_system                                       # â‡’ [[x == 5, y == 1]]

# â”€â”€ 2 Â· Numerical roots when closed form is hard or unnecessary â”€â”€â”€â”€
f  = sin(x) - x/2                                 # transcendental equation
root = find_root(f, 1, 2)                         # numeric root in (1,2)
root                                              # â‡’ 1.89549426703398

all_nroots = nroots(x^3 - 2*x - 5)                # numeric roots of a cubic
all_nroots                                       # â‡’ [2.09455148154233]


```
</details>

- **Exact solve** returns symbolic expressions when Sage can find a closedâ€‘form answer.  
- **Numerical methods** (`find_root`, `nroots`) give floatingâ€‘point approximationsâ€”handy for transcendental equations or messy polynomials.

### 3.4â€‚Calculusâ€¯â€”â€¯DifferentiationÂ &Â Integration

| Operation | Purpose | Sage Command | Example |
|-----------|---------|--------------|---------|
| **Differentiation (symbolic)** | Compute *n*â€‘th derivative analytically | `diff(expr, var[, n])` | `diff((sin(x)+x^2)*e^x, x)` |
| **Indefinite integration** | Find antiderivative | `integrate(expr, var)` | `integrate(cos(x)^2, x)` |
| **Definite integration** | Exact integral over `[a,â€¯b]` | `integrate(expr, (var, a, b))` | `integrate(sin(x)^2, (x, 0, pi))` |
| **Numeric approximation** | Float evaluation of any symbolic result | `N(expr)`Â orÂ `expr.n()` | `N(integrate(sin(x)/x, (x,0,1)))` |

<details>
<summary><strong>ğŸ’» code (click to see more) </strong></summary>

```python
# Declare a symbolic variable
x = var('x')

# â”€â”€ 1 Â· Differentiation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
f = (sin(x) + x^2) * e^x

# First derivative of f(x)
df1 = diff(f, x)
df1   # â‡’ (e^x)*(sin(x) + x^2) + e^x*(cos(x) + 2*x)

# Second derivative of f(x)
df2 = diff(f, x, 2)
df2   # â‡’ e^x*(sin(x) + x^2) + 2*e^x*(cos(x) + 2*x) + e^x*(-sin(x) + 2)

# â”€â”€ 2 Â· Indefinite Integrals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int1 = integrate(cos(x)^2, x)
int1  # â‡’ 1/2*x + 1/4*sin(2*x)

int2 = integrate(1/(1 + x^4), x)
int2  # â‡’ 1/2*sqrt(2)*arctan(...) âˆ’ 1/2*sqrt(2)*arctan(...)

# â”€â”€ 3 Â· Definite Integrals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def_int1 = integrate(sin(x)^2, (x, 0, pi))
def_int1  # â‡’ pi/2

gauss = integrate(exp(-x^2), (x, -oo, oo))  # Gaussian integral
gauss   # â‡’ sqrt(pi)

# â”€â”€ 4 Â· Numeric Evaluation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
num_val = N(integrate(sin(x)/x, (x, 0, 1)))
num_val  # â‡’ 0.946083070367183

f_prime_val = diff(f, x).subs(x=1)
N(f_prime_val)  # â‡’ 4.15498308550022

```
</details>

### 3.5â€‚Solving Differential Equations


| Operation | Purpose | Sage Command | Minimal Example |
|-----------|---------|--------------|-----------------|
| **Symbolic solve** | Closedâ€‘form when available | `desolve(ode, y[, ics])` | `desolve(diff(y,t) == yâ€‘t, y)` |
| **Laplace method** | LTI ODEs via Laplace transform | `desolve_laplace(ode, y[, ics])` | `desolve_laplace(diff(y,t,2)+y==0, y)` |
| **Numerical IVP (RK45 / odeint)** | Highâ€‘accuracy float solution | `desolve_odeint(f, y0, t_span)` | `desolve_odeint(f, 2, srange(0,5,0.1))` |
| **Eulerâ€™s explicit method** | Simple stepâ€‘byâ€‘step approximation for systems | `ode_solver(method='euler')` | ```sage\nS = ode_solver();\nS.method = 'euler';\nS.solve()?``` |
| **General ODE solver** | Fine control (step, events, stiffness) | `ode_solver()` | `ode_solver().solve()` |

> **Tip:** In the Euler example, you would also assign `S.function`, `S.ics`, and `S.t_span` before calling `S.solve()`.

#### 3.5.1â€‚Symbolic Solution (â€¯`desolve`â€¯)



```python
sage: var('t')
sage: y = function('y')(t)

# Firstâ€‘order linear ODE:  y' = yâ€¯âˆ’â€¯t
sage: desolve(diff(y, t) == y - t, y)
y(t) == t + 1 + C*e^t

# Secondâ€‘order ODE with initial conditions:  y'' + y = 0,  y(0)=1,  y'(0)=0

sage: desolve(diff(y, t, 2) + y == 0, y, ics=[0, 1, 0])
y(t) == cos(t)
```


#### 3.5.2â€‚Laplaceâ€‘Transform Method

```python
# Declare the independent variable and symbolic function
t = var('t')
y = function('y')(t)

# Solve the second-order ODE using the Laplace transform:
# y'' + y = sin(t), with y(0) = 0, y'(0) = 1
sol = desolve_laplace(diff(y, t, 2) + y == sin(t), y, ics=[0, 0, 1])
sol  # â‡’ y(t) == 1/2*sin(t) - 1/2*t*cos(t)

```


#### 3.5.3 Numerical IVP (Rungeâ€“Kutta / odeint)

```python
# Define the ODE: y' = y - t
f(t, y) = y - t

# Create a time range from t=0 to t=5 with step size 0.1
ts = srange(0, 5, 0.1)

# Numerically solve the IVP y' = y - t with initial condition y(0) = 2
ys = desolve_odeint(f, y0=2, t_span=ts)

# Plot the numerical solution (y values vs time)
list_plot([(ts[i], ys[i][0]) for i in range(len(ts))],
          plotjoined=True, axes_labels=["t", "y(t)"])
# â‡’ smooth curve showing y(t) evolving over [0, 5]

```


#### 3.5.4â€‚Eulerâ€™s Method for a System

```python
# Define time variable and symbolic functions y1(t), y2(t)
t = var('t')
y1, y2 = function('y1')(t), function('y2')(t)

# System of ODEs:
#   dy1/dt = y1 - t
#   dy2/dt = -y1 + y2
f = [
    lambda t, u, v: u - t,   # dy1/dt
    lambda t, u, v: -u + v   # dy2/dt
]

# Set up Euler's method using Sage's ODE solver
S = ode_solver()
S.function    = f
S.ics         = (0, 2, 1)       # initial time t=0, y1(0)=2, y2(0)=1
S.t_span      = [0, 5]          # solve from t = 0 to t = 5
S.num_steps   = 50
S.method      = 'euler'
S.ode_solve()

# Extract solution as list of (t_i, (y1_i, y2_i)) points
points = list(zip(S.t_values, S.y_values))
points[:5]  # show first few entries
```